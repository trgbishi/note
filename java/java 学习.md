Java 一个源文件中只能有一个public类（与文件名一致），其他类都为非public类

##修饰符
###static 修饰符
静态成员变量属于整个类，可以通过类名和对象名调用；
类静态方法无法直接访问非静态成员，需要通过创建类对象来访问；
静态成员的内存空间在类卸载时才会被回收；

###final 修饰符
* final 变量只能被初始化一次，之后不能再改变；
* final 方法不能被之类方法覆盖，但可以被继承；
* final 对象的引用不能改变，但对象里的数据可以改变；
* final 类不能被继承，没有子类；

###abstract 修饰符
####抽象类：
* 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充；
* 一个类不能同时被 abstract 和 final 修饰；
* 如果一个类包含抽象方法，那么该类一定要声明为抽象类，但是抽象类可以不包含抽象方法；

####抽象方法
* 抽象类中的抽象方法只是声明，不包含方法体，以分号结尾（如：public abstract sample();）；
* 抽象方法不能被声明成 final 和 static，构造方法，类方法（用static修饰的方法）不能声明为抽象方法；
* 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类；

###synchronized 修饰符
synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符(+default)

###transient 修饰符
* 序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量；
* 该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型；

###volatile 修饰符
* volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个；
* 一个 volatile 对象引用可能是 null；



##继承
###构造器：
* 子类不能继承父类的构造器，但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器。
* 如果父类有无参构造器，则在子类的构造器中用super调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。
* Java自动提供了一个默认构造方法，它把所有成员初始化为0。

###继承的特性
* 子类拥有父类非private的属性及方法，还可以拥有自己的属性和方法；
* 子类可以用自己的方式实现父类的方法；
* Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性；
* 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）；

###extends关键字
* 在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。
* implements关键字：使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。
* super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类；
* this关键字：指向自己的引用。

###方法的重写规则
* 参数列表必须完全与被重写方法的相同；
* 返回类型必须完全与被重写方法的返回类型相同；
* 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
* 父类的成员方法只能被它的子类重写。
* 声明为final的方法不能被重写。
* 声明为static的方法不能被重写，但是能够被再次声明。
* 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
* 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
* 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
* 构造方法不能被重写。
* 如果不能继承一个方法，则不能重写这个方法

###多态存在的三个必要条件
* 继承
* 重写
* 父类引用指向子类对象
    比如：
    Parent p = new Child();
    当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。
    多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。



##接口
* 一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类；
* 在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象；
* 一个接口能继承另一个接口，使用extends关键字，且  接口允许多继承，即 extends后面接多个接口。

###接口与类的区别：
1. 接口不能用于实例化对象。
2. 接口没有构造方法。
3. 接口中所有的方法必须是抽象方法。
4. 接口不能包含成员变量，除了 static 和 final 变量。
5. 接口不是被类继承了，而是要被类实现。
6. 接口支持多继承。

###接口特性
1. 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。
2. 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。
3. 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。

###抽象类和接口的区别
1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。
3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

eg:
    import java.lang.*;
    //引入包
    public interface NameOfInterface
    {
    	//任何类型 final, static 字段
    	//抽象方法
    }

##多线程
http://www.cnblogs.com/wxd0108/p/5479442.html
###几种状态
####新建状态:
使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。
####就绪状态:
当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。
####运行状态:
如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。
####阻塞状态:
如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：
1. 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。
2. 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。
3. 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。
####死亡状态:
一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

###Java 提供了三种创建线程的方法：
1. 通过实现 Runnable 接口；
2. 通过继承 Thread 类本身；（继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行）
3. 通过 Callable 和 Future 创建线程。

###通过 Callable 和 Future 创建线程
1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。
2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。
3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。
4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。

###此外
1. 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。
2. 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。



##Java 8 的一些特性
###Java 8 lambda表达式
http://www.runoob.com/java/java8-lambda-expressions.html
以下是lambda表达式的重要特征:
1. 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。
2. 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。
3. 可选的大括号：如果主体包含了一个语句，就不需要使用大括号。
4. 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。

此外
1. lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。
2. 我们也可以直接在 lambda 表达式中访问外层的局部变量：
3. lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）

###默认方法
java 8中，接口增加了一个特性-默认方法，即可以在接口里面有一个实现的方法（加default）

###Java 8 方法引用
方法引用的标准形式是:类名::方法名。（注意：只需要写方法名，不需要写括号）
http://www.runoob.com/java/java8-method-references.html
https://www.cnblogs.com/JohnTsai/p/5806194.html
有以下四种形式的方法引用:
1. 引用静态方法	ContainingClass::staticMethodName
2. 引用某个对象的实例方法	containingObject::instanceMethodName
3. 引用某个类型的任意对象的实例方法	ContainingType::methodName
4. 引用构造方法	ClassName::new

###Java 8 函数式接口
http://www.runoob.com/java/java8-functional-interfaces.html
将函数做参数
除非对这些接口很熟悉，否则想不起来用的

###Java 8 Stream
更加简洁地做运算

###Java 8 Optional


##其他
###java泛型了解一下？
http://www.runoob.com/java/java-generics.html
可以实现的功能：
1. 功能相同，参数不同类型的函数，可以用泛型；
2. 可以用extends限定1中类型的上限；
3. 泛型类；
4. 类型通配符，使用?代替具体的类型参数；上限也用extends；


###序列化与反序列化
序列化：将类的对象表示为字节序列；(该类所有属性必须都是可序列化的，否则必须注明的短暂的；该类必须实现 java.io.Serializable 对象)
反序列化：将字节序列强转为对象；


###增强型for循环
Java5 引入了一种主要用于数组的增强型 for 循环，Java 增强 for 循环语法格式如下:
    for(声明语句 : 表达式)
    {
    	//代码句子
    }
eg:
    int [] numbers = {10, 20, 30, 40, 50};
    for(int x : numbers ){
    	...
    }
    
    
###StringBuilder与StringBuffer
由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。

###vector与arraylist
vector是线程安全的，但是相对会慢一些

###数组作为函数的参数
数组可以作为参数传递给方法。
例如，下面的例子就是一个打印 int 数组中元素的方法:
    public static void printArray(int[] array) {
    	for (int i = 0; i < array.length; i++) {
    		System.out.print(array[i] + " ");
    	}
    }
下面例子调用 printArray 方法打印出 3，1，2，6，4 和 2：
printArray(new int[]{3, 1, 2, 6, 4, 2});
数组作为函数的返回值
    public static int[] reverse(int[] list) {
    	int[] result = new int[list.length];
    	for (int i = 0, j = result.length - 1; i < list.length; i++, j--) {
    		result[j] = list[i];
    	}
		return result;
    }


###可变参数
* JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。
* 方法的可变参数的声明如下所示：
	typeName... parameterName
* 在方法声明中，在指定参数类型后加一个省略号(...) ；
* 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。


###其它笔记：（暂时用不到的不记）
1.线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。
使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。

2.ArrayList 尽量使用 ArrayList(int initialCapacity) 初始化。

3.线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
说明：Executors 各个方法的弊端：
1）newFixedThreadPool 和 newSingleThreadExecutor:
主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。
2）newCachedThreadPool 和 newScheduledThreadPool:
主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。

4.多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题

5.volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。

6.HashMap 的扩容死链，多线程并发同时resize

7.不要把代码写的复杂，可读性更重要

8.不要捕获 Java 类库中定义的继承自 RuntimeException 的运行时异常类，如：
IndexOutOfBoundsException / NullPointerException，这类异常由程序员预检查来规避，保证程序健壮性