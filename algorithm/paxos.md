### 3个角色：
* 提案者
* 接受者
* 学习者

### 2个阶段：
> 前置条件：
    由于网络原因，接受者接收消息存在着不稳定性

#### 准备阶段
    提案者向接受者广播 ready request,request里带一个不同的编号n
    每个接受者都会收到0或具体不等的req，对比收到的所有n，回复max-n
#### 提案阶段  
    当提案者收到半数以上回复都是自己的编号n时，广播<n,value>
    当提案者收到的回复，大多数都是自己的n时，广播<n,value>

    每个接受者都会收到若干个<n,value>集合，对比此时收到的所有n，
        若n<max-n，忽略
        若n=max-n，记录value
        若n>max-n
            检查value，若value为空，即还没有收到对应max-n的记录。修改max-n=n,记录value
            检查value，若value有值，则向该编号的提案者回复<max-n,已记录value>

    当提案者发出提案后收到了多个<max-n,value>,对比这些max-n，修改自己value为最大的max-n对应value。重新广播<n,value>
            
        


### 思考
#### 取消准备阶段呢
    所有提案者都广播<n,value>,接受者等待一段时间，将这段时间收到的max-n记录,value记录，并回复<max-n，value>
    提案者接收到回复后，若max-n比自己的n大，则广播<n,max-value>
    递归下去，直到某一轮所有接受者的值都不再改变停止，即收敛
    这种逻辑其实收敛速度取决于网络环境，若真的存在单个提案者只能通信小部分接受者的情况，那就需要一遍遍收敛
    至于逻辑上有没有漏洞我不确定

#### 提案者也是接受者
    正常情况下，提案者往往也是接受者。所以每个接受者本身就自带一个n的

#### 学习者
    学习者其实是不具有投票权及提案权的，所以最后定完后通知一声学习者就行了

#### 想太多
    另外我觉得消息接收有先后顺序是可以的，毕竟即使是毫秒级也是有先后的
    但是如果真的存在大批量的单线网络中断，即全网只有20%的接受者收到单个提案者消息的，这种情况还是解决一下网络问题比较好
    我草稿上乱画的时候，最大的疑惑也是如何解决单个提案者只能通信小部分接受者的情况。
    但其实应该不存在这种网络状态吧哈哈，要么彻底掉线了，要么就网内全部联通