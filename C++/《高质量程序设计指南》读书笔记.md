###1.C语言getchar()返回的是int值，返回值赋给char类型会有数据丢失风险
###2.关于返回对象值与返回指针p120
* 以重载运算符=与+为例，'operator = ',用this指针取当前对象，与传入对象对比，相同返回*this的引用，这样不必将*this保存到外部存储单元中，节省开销;
* ’operator +',在函数内定义sum来取两个传参之和，返回sum的引用的话，离开函数就会丢失，所以这里要返回sum值;
###3.“创建一个临时对象并返回它”与“先创建一个局部对象temp并返回它的结果”是不同的，例如：
```C++
	return String(s1+s2);
```
与
```C++
	String result（s1+s2);
    return result;
```
这两种操作是不同的，后者是一个临时变量，外部调用该函数时并不能获得想要的结果
###4.存储类型及作用域规则
* extern和static用来标识永久生存期限的变量和函数，而auto和register则用来标识临时生存期限的变量。
* 默认情况下，全局变量和全局函数的存储类型是extern的，能够被定义在它们之后的同一个编译单元内的函数所调用。
* 如果变量和函数被显示地加上extern声明，那么其他编译单元的函数也能调用它们。
* 显示地声明为static的全局变量和全局函数具有static存储类型，只能被同一个编译单元内的函数调用。如果在定义了它的编译单元之外的其他编译单元中显式地用extern声明，也能访问。
* register修饰的变量会被直接加载到CPU寄存器中，可以避免在寄存器和内存之间频繁地交换数据，但register一般由编译器来添加，不需要掌握。
* 局部变量具有程序块作用域，由{}决定。
* 在函数中嵌套的程序块可以定义相同名字的变量，在内层的变量会遮蔽外层的同名变量。此时有两种方法来访问同名的数据成员，使用this或二元作用域解析运算符(::),例如，this->flag = flag;或ClassName::flag = flag;
* 即使局部变量的存储类型声明为static，它仍然具有程序块作用域。
###5.连接类型
* 连接类型分为外连接，内连接，五连接三种。
* 当单独编译每一个源文件正常通过，编译整个projict时出现“连接失败”。就是因为它们的连接类型都是外连接的，而且其存储类型为extern，结果导致连接出现二义性，这并不由它们的作用域所致。如果同名变量或同名函数中的一个定义为static（变成内连接），就可以正常连接了。
###6.const

const不能修饰输出参数，只能修饰输入参数；
const 不仅可以修饰指针本身，还可以修饰指针指向的内存单元
```C++
	const chat* const pStr;
```


如果给“指针传递”的函数返回值加const，那么该返回值只能赋值给加const修饰的同类型指针（除非强转):
```C++
	const char *getString(void);
```
错误的调用方式：
```C++
	char *str = getString();
```
正确的调用方式：
```C++
	const char *str = getString();
```


如果函数返回值参用“值传递”的方式，由于函数会把返回值复制到外部临时的存储单元中，所以加const修饰一般没有意义;（书上说值传递返回ADT/UDT对象，引用或指针时，作为左值调用会出现问题，但是什么是ADT/UDT，左值调用函数又是什么东西，先略）
###7.指针传递
我们可以把函数的参数或返回值类型声明为指针类型。此时，函数接受的参数或返回值就是地址，而不是指针所指的内存单元的值。
###8.数组的本质
```C++
	a[3]=100;
```
等价于
```C++
	int &ri = a[3];
	ri = 100;
```
即编辑器计算地址值，**a+3*sizeof(int)**,并返回该地址所指对象的引用。


C++/C数组本身不会保存下标值与元素对象之间的对应关系，因此无法直接通过下标索引来定位真正的数组元素对象。程序中用指针会损害程序的清晰性：
```C++
	a[3] = 100;//转换为*(a+3) = 100;
```
	

你不能妄想仅通过数组名就达到访问整个数组的目的，除非它是字符数组。基于这个原因，任何两个数组之间都不能直接赋值，即使同类型。需要遍历或者**memcpy()**

###9.动态创建、初始化和删除数组的方法
对于字符数组，其动态创建的正确方法为：
```C++
	char *p = new char[1025];//分配空间
```
正确的释放方法是：
```C++
	delete []p;//删除数组空间
```
如果使用：
```C++
	delete p;
```
只会释放数组的第一个元素的空间，后面的1024个char空间全部丢失。因为编译器认为p只是一个char指针，而不是数组指针.
    
对于多维数组，如：
```C++
	char (*p3)[4] = new char[5][4];
    int (*p4)[5] = new int[3][5];
    char (*p5)[5][7] = new char[20][5][7];
 ```
其删除方式：
```C++
	delete []p3;
    delete []p4;
    delete []p5;
```
不存在这样的赋值与删除语句：
```C++
	char *p1 = new char[5][3];
    int *p2 = new int[4][6];
    delete [][]p3;
    delete [][]p4;
    delete [][][]p5;
```
###10.函数指针(p148)
抄三个demo，见到能认识就行了，暂时。
* demo1：
```C++
	typedef int_cdecl (*FuncPtr)(const char *);
    FuncPtr fp_1 = strlen;
    FuncPtr fp_2 = puts;
    double _cdecl (*fp_3)(double) = sqrt;
    
    int len = fp_1("hello");//直接函数指针变量当作函数名，然后填入参数
    double d = (*fp_3)(10.25);//将函数指针的反引用作为函数名，然后填入参数
```
    
* demo2，函数指针数组
```C++
	double cdecl (*fp[5])(double) = {sqrt,fabs,cos,sin,exp};
    for(int k =0;k<5;k++)
    {
    	cout<<"Result:" << fp[k](10.25)<endl;//运行时连接
```

* demo3,类成员函数指针
```C++
	class CTest {
    public:
    	void f(void) { cout << "CTest::f()"<<endl; }//普通成员函数
        static void g(void) { cout<<"CTest::g()" <<endl;}//静态成员函数
        virtual void h(void) { cout << "CTest::h() " << endl;}//虚拟成员函数
       	...
	};
    void main()
    {
    	typedef void (*GFPtr)(void);//定义一个全局函数指针类型
        GFPtr fp = CTest::g;//取静态成员函数地址的方法和取一个全局函数的地址相似        
        fp();//通过函数指针调用类静态成员函数
        typedef void (CTest::*MemFuncPtr)(void);//声明类成员函数指针类型
        MemFuncPtr mfp_1 = &CTest::f;//声明成员函数指针变量并初始化
        MemfuncPtr mfp_2 = &CTest::h;//注意获取成员函数地址的方法
        CTest theObj;
        (theObj.*mfp_1)();//使用对象和成员函数指针调用成员函数
        (theObj.*mfp_2)();
        CTest *pTest = &theObj;
        (pTest->*mfp_1)();//使用对象指针和成员函数指针调用成员函数
        (pTest->*mfp_2)();
	}
        
    }
    }
```
###11.引用和指针的比较
* 引用在创建时就必须初始化，指针不用
* 不存在NULL引用，引用必须与合法的存储单元关联;而指针可以是NULL;
* 引用一旦被初始化为指向一个对象，它就不能被改变为对另一个对象的引用;而指针在任何时候都可以改变为指向另一个对象;给引用赋值不是改变它与原始对象的绑定关系，而是同时改变它们的值

###12.struct
就C++语言本身来讲，struct和class除了“默认的成员访问权限”这一点不同外，没有任何区别。struct成员的默认访问限定符为public，而class成员的默认访问限定符为private。
###13.C++面向对象程序设计方法概述
emmm....应该是最重要的模块了，但是该部分太难记了，还是需要慢慢写代码来熟悉的
###14.内存管理
* 将指针作为参数传入函数，并在函数内用入参申请内存，这种操作必然导致失败。原理上形参是实参的临时副本，指向相同的内容，当形参申请内存，就是实参申请。但实际上不是，形参申请了新内存后，直接改变了这个临时副本本身，即指向了新的内存空间，但是函数外的实参没有变。所以每次执行函数数都会导致一块内存泄漏。用**“指向指针的指针”**或者**“指针的引用”**才可以。
* 用函数返回值来传递动态内存，即函数内申请，并返回该指针。但是这里应该注意
	char *getString(void)
    {
    	char p[] = "hello world";//用字符串常量来初始化数组的内存空间
        return p;
    }
    char *str =NULLl
    str = getString();
    这种方案将导致错误，str虽然不再是NULL，但也不是想要的东西
    
    正确的做法应该是:
    char *getString(void)
    {
    	char *p = "hello world";
        return p;
    }
* 使用free或delete释放指针内存，但是指针地址不变，只是变成了“野指针”。所以释放完，还要将指针置为NULL
* 当然现在用nullptr来表示指针为空，同时，用智能指针的话就不用管内存释放的事情了。这本书还是比较旧了
    